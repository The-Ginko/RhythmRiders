<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suspension Testbed v1</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
        }
        /* V46: Style for the PIXI overlay canvas */
        #pixi-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* Allows mouse events to pass through to the Matter canvas */
        }
        .controls-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10; /* Ensure it's on top */
        }
    </style>
</head>
<body>
    <div class="controls-info">
        <p>W/S: Throttle | A/D: Torque</p>
        <p>G: Toggle Air-Tune Mode (Gravity Off)</p>
    </div>
    <script src="./libs/matter.min.js"></script>
    <script src="./libs/matter-tools.min.js"></script>
    <script>
        // --- Setup ---
        const {
            Engine, Render, Runner, World, Bodies, Body, Composite, Vector, Constraint, Events, Mouse, MouseConstraint
        } = Matter;
    
        // --- Engine Setup ---
        const engine = Engine.create();
        const world = engine.world;
        engine.gravity.y = 1;
    
        // --- Matter Renderer Setup ---
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#1a1a2e'
            }
        });
        Render.run(render);
    
        // --- Game State, Controls, and Creation Functions ---
        const keys = {};
        let bike;
    
        function drawSelectedConstraintHighlight(context, constraint) {
            const bodyA = constraint.bodyA;
            const bodyB = constraint.bodyB;
            if (!bodyA || !bodyB) return;
    
            // Correctly translate world coordinates to canvas coordinates
            const startPoint = Vector.add(bodyA.position, constraint.pointA);
            const endPoint = Vector.add(bodyB.position, constraint.pointB);
            const bounds = render.bounds;
    
            const startCanvas = { x: (startPoint.x - bounds.min.x), y: (startPoint.y - bounds.min.y) };
            const endCanvas = { x: (endPoint.x - bounds.min.x), y: (endPoint.y - bounds.min.y) };
    
            context.beginPath();
            context.moveTo(startCanvas.x, startCanvas.y);
            context.lineTo(endCanvas.x, endCanvas.y);
            context.lineWidth = 5;
            context.strokeStyle = 'rgba(255, 229, 59, 0.9)';
            context.stroke();
        }
            
        // --- Initialization ---
        function init() {
            // 1. Create Runner and Tools FIRST for correct initialization
            const runner = Runner.create();
            const gui = MatterTools.Gui.create(engine, runner);
            const inspector = MatterTools.Inspector.create(engine, render);
    
            // 2. Add all world objects
            createDiagnosticTrack();
            bike = createBike(400, 400, MOTOCROSS_PRESET);
    
            // 3. Add mouse controls
            const mouse = Mouse.create(render.canvas);
            const mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: { stiffness: 0.2, render: { visible: true } }
            });
            World.add(world, mouseConstraint);
            render.mouse = mouse;
    
            // 4. Set up standard event listeners
            window.addEventListener('keydown', (e) => { keys[e.key] = true; });
            window.addEventListener('keyup', (e) => { keys[e.key] = false; });
            Events.on(runner, 'beforeUpdate', handleControls);
            
            // --- THE CORRECTED RENDER LOOP ---
            Events.on(render, 'afterRender', function() {
                // Check if there is anything selected in the inspector
                if (inspector.selected.length > 0) {
                    // Get the actual Matter.js object from the .data property
                    const selection = inspector.selected[0].data;
    
                    // Check if the selection is a constraint before drawing
                    if (selection && selection.type === 'constraint') {
                        drawSelectedConstraintHighlight(render.context, selection);
                    }
                }
            });
            
            // 5. Run the engine
            Runner.run(runner, engine);
        }
    
        // --- (Full function definitions for bike, track, and controls) ---
        function createDiagnosticTrack() {
            World.add(world, [
                Bodies.rectangle(400, 600, 800, 50, { isStatic: true }),
                Bodies.rectangle(1200, 500, 800, 50, { isStatic: true, angle: -Math.PI / 8 }),
                Bodies.rectangle(1900, 420, 600, 50, { isStatic: true })
            ]);
        }
        const MOTOCROSS_PRESET = {
            chassis: { width: 100, height: 20, density: 0.02 },
            rearWheel: { offsetX: -50, offsetY: 30, radius: 25, friction: 0.9, density: 0.015 },
            frontWheel: { offsetX: 50, offsetY: 30, radius: 25, friction: 0.3, density: 0.01 },
            rearSuspension: { stiffness: 0.01, damping: 0.05, length: 60 },
            frontSuspension: { stiffness: 0.01, damping: 0.05, length: 60 }
        };
        function createBike(x, y, preset) {
            const bikeComposite = Composite.create({ label: 'Motorcycle' });
            const group = Body.nextGroup(true);
            const chassis = Bodies.rectangle(x, y, preset.chassis.width, preset.chassis.height, { collisionFilter: { group: group }, density: preset.chassis.density });
            const rearWheel = Bodies.circle(x + preset.rearWheel.offsetX, y + preset.rearWheel.offsetY, preset.rearWheel.radius, { collisionFilter: { group: group }, friction: preset.rearWheel.friction, density: preset.rearWheel.density });
            const frontWheel = Bodies.circle(x + preset.frontWheel.offsetX, y + preset.frontWheel.offsetY, preset.frontWheel.radius, { collisionFilter: { group: group }, friction: preset.frontWheel.friction, density: preset.frontWheel.density });
            const rearSuspension = Constraint.create({
                label: 'Rear Suspension', bodyA: chassis, pointA: { x: preset.rearWheel.offsetX, y: 0 }, bodyB: rearWheel, stiffness: preset.rearSuspension.stiffness, damping: preset.rearSuspension.damping, length: preset.rearSuspension.length
            });
            const frontSuspension = Constraint.create({
                label: 'Front Suspension', bodyA: chassis, pointA: { x: preset.frontWheel.offsetX, y: 0 }, bodyB: frontWheel, stiffness: preset.frontSuspension.stiffness, damping: preset.frontSuspension.damping, length: preset.frontSuspension.length
            });
            Composite.add(bikeComposite, [chassis, rearWheel, frontWheel, rearSuspension, frontSuspension]);
            World.add(world, bikeComposite);
            return bikeComposite;
        }
        function handleControls() {
            if (!bike) return;
            const rearWheel = bike.bodies[1];
            const chassis = bike.bodies[0];
            if (keys['w'] || keys['ArrowUp']) { rearWheel.torque = 0.5; }
            if (keys['s'] || keys['ArrowDown']) { rearWheel.torque = -0.2; }
            if (keys['a'] || keys['ArrowLeft']) { chassis.torque = -0.5; }
            if (keys['d'] || keys['ArrowRight']) { chassis.torque = 0.5; }
        }
    
        // --- Start the simulation ---
        init();
    </script>
</body>
</html>
