<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matter.js Interactive Sandbox</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(20, 20, 20, 0.7);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            -webkit-user-select: none;
            user-select: none;
        }
        #editor-panel {
            top: 20px;
            left: 20px;
            width: 250px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        #controls-panel {
            top: 20px;
            right: 20px;
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group select, .control-group button {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            font-family: 'Inter', sans-serif;
        }
        .control-group button {
            cursor: pointer;
            background-color: #4285F4;
            border-color: #4285F4;
        }
        .ui-panel h3 {
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            font-weight: 500;
        }
        .slider-group, .input-group, .checkbox-group {
            margin-bottom: 12px;
        }
        .slider-group label, .input-group label, .checkbox-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px 0;
        }
        .slider-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .slider-group input[type="range"]:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .input-group input[type="number"] {
            width: 48%;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px;
        }
        .input-group div {
            display: flex;
            justify-content: space-between;
        }
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            pointer-events: none;
        }
        .delete-button {
            width: 100%;
            padding: 8px;
            margin-top: 15px;
            border-radius: 5px;
            border: 1px solid #DB4437;
            background-color: #DB4437;
            color: #fff;
            cursor: pointer;
        }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); display: none;
            justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            background: #222; padding: 20px 30px; border-radius: 10px; text-align: center;
        }
        .modal-content p { margin: 0 0 20px 0; }
        .modal-buttons button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 0 10px; }
        #confirm-delete { background-color: #DB4437; color: white; }
        #deny-delete { background-color: #555; color: white; }
        /* New styles for the Composites Feature */
        .highlight-green {
            stroke: #0F9D58 !important;
            stroke-width: 4 !important;
        }
        .highlight-blue {
            stroke: #4285F4 !important;
            stroke-width: 4 !important;
        }
        #composite-editor, #assign-to-composite-section {
            display: none;
        }
        #composite-name-input {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            font-family: 'Inter', sans-serif;
            text-align: center;
            margin-bottom: 10px;
        }
        .message-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #444; color: #fff; padding: 15px 30px; border-radius: 8px;
            z-index: 1001; opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
        #load-modal textarea {
            width: 100%;
            min-height: 150px;
            background: #111;
            color: #eee;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 5px;
            font-family: monospace;
            resize: vertical;
        }
        //styling for controls sliders with range control 
        .slider-with-controls {
    margin-bottom: 12px;
}
.slider-with-controls label {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-size: 14px;
}
.range-and-controls {
    display: flex;
    align-items: center;
    gap: 5px;
}
.range-and-controls input[type="range"] {
    flex-grow: 1;
    cursor: pointer;
}
.range-controls {
    display: flex;
    flex-direction: column;
    gap: 2px;
}
.range-controls button {
    height: 14px;
    width: 14px;
    line-height: 0;
    padding: 0;
    border-radius: 3px;
    border: 1px solid #555;
    background-color: #333;
    color: #fff;
    font-size: 10px;
    cursor: pointer;
}
.range-controls button:active {
    transform: translateY(1px);
}
.range-display {
    font-size: 10px;
    color: #888;
    display: block;
    text-align: right;
}
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
    <div id="editor-panel" class="ui-panel">
        <h3 id="ui-title">New Constraint</h3>
        <div class="control-group">
            <label>Select Existing Constraint</label>
            <select id="existing-constraint-list"></select>
        </div>
        
        <div id="composite-editor">
            <input type="text" id="composite-name-input" placeholder="Composite Name">
            <p id="composite-editor-message" style="display:none; font-size: 12px; margin: 10px 0;">Object is selected. To manipulate it, you must first remove it from this composite.</p>
            <button id="remove-from-composite-btn" class="delete-button" style="display: none; margin-top: 0;">Remove Selected Object</button>
            <button id="delete-composite-btn" class="delete-button">Delete Composite</button>
        </div>

        <div id="constraint-editor">
            <div class="slider-group">
                <label for="stiffness">Stiffness: <span id="stiffness-value">0.10</span></label>
                <input type="range" id="stiffness" min="0" max="1" step="0.01" value="0.1">
            </div>
            <div class="slider-group">
                <label for="damping">Damping: <span id="damping-value">0.050</span></label>
                <input type="range" id="damping" min="0" max="0.1" step="0.001" value="0.05">
            </div>
            <div class="slider-group">
                <label for="length">Length: <span id="length-value">100</span></label>
                <input type="range" id="length" min="0" max="500" step="1" value="100">
            </div>
            <div class="input-group">
                <label>Point A Offset (x, y)</label>
                <div><input type="number" id="constraint-point-ax" step="1" value="0"><input type="number" id="constraint-point-ay" step="1" value="0"></div>
            </div>
            <div class="input-group">
                <label>Point B Offset (x, y)</label>
                <div><input type="number" id="constraint-point-bx" step="1" value="0"><input type="number" id="constraint-point-by" step="1" value="0"></div>
            </div>
            <button id="delete-constraint-btn" class="delete-button" style="display: none;">Delete Constraint</button>
        </div>

        <div id="object-editor" style="display: none;">
            <div id="assign-to-composite-section">
                <div class="control-group">
                    <label>Assign to Composite</label>
                    <select id="assign-composite-list"></select>
                    <button id="add-to-composite-btn" style="margin-top: 10px;">Assign</button>
                </div>
            </div>
             <div class="checkbox-group">
                <label for="is-static">Static</label>
                <input type="checkbox" id="is-static">
            </div>
            <div class="slider-group">
                <label for="angle">Angle: <span id="angle-value">0</span>°</label>
                <input type="range" id="angle" min="0" max="360" step="1" value="0">
            </div>
            <div class="slider-group">
                <label for="restitution">Bounciness: <span id="restitution-value">0.50</span></label>
                <input type="range" id="restitution" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="slider-group">
                <label for="friction">Friction: <span id="friction-value">0.10</span></label>
                <input type="range" id="friction" min="0" max="1" step="0.01" value="0.1">
            </div>
            <div class="slider-group">
                <label for="friction-static">Static Friction: <span id="friction-static-value">0.50</span></label>
                <input type="range" id="friction-static" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="slider-group">
                <label for="friction-air">Air Friction: <span id="friction-air-value">0.010</span></label>
                <input type="range" id="friction-air" min="0" max="0.1" step="0.001" value="0.01">
            </div>
             <div class="slider-group">
                <label for="density">Density: <span id="density-value">0.001</span></label>
                <input type="range" id="density" min="0.001" max="0.1" step="0.001" value="0.001">
            </div>
            <div class="input-group">
                <label>Position (x, y)</label>
                <div><input type="number" id="position-x" step="1"><input type="number" id="position-y" step="1"></div>
            </div>
            <div class="input-group">
                <label>Center of Mass Offset (x, y)</label>
                <div><input type="number" id="com-offset-x" step="1" value="0"><input type="number" id="com-offset-y" step="1" value="0"></div>
            </div>
            <div id="size-editor-circle" class="slider-group" style="display: none;">
                <label for="radius">Radius: <span id="radius-value">30</span></label>
                <input type="range" id="radius" min="10" max="100" step="1" value="30">
            </div>
            <div id="size-editor-rect" style="display: none;">
                <div class="slider-with-controls">
                    <label for="width">Width: <span id="width-value">50</span></label>
                    <div class="range-and-controls">
                        <input type="range" id="width" min="10" max="200" step="1" value="50">
                        <div class="range-controls">
                            <button class="range-up" data-target="width" data-scale="10">▲</button>
                            <button class="range-down" data-target="width" data-scale="0.1">▼</button>
                        </div>
                    </div>
                    <span class="range-display">Range: 10 - 200</span>
                </div>
                <div class="slider-with-controls">
                    <label for="height">Height: <span id="height-value">50</span></label>
                    <div class="range-and-controls">
                        <input type="range" id="height" min="10" max="200" step="1" value="50">
                        <div class="range-controls">
                            <button class="range-up" data-target="height" data-scale="10">▲</button>
                            <button class="range-down" data-target="height" data-scale="0.1">▼</button>
                            </div>
                    </div>
                    <span class="range-display">Range: 10 - 200</span>
                </div>
            </div>
             <div id="size-editor-polygon" class="slider-group" style="display: none;">
                <label for="polygon-size">Size: <span id="polygon-size-value">40</span></label>
                <input type="range" id="polygon-size" min="10" max="100" step="1" value="40">
            </div>
            <div class="input-group">
                <label>Collision Group</label>
                <input type="number" id="collision-group" style="width: 100%;">
            </div>
            <div class="input-group">
                <label>Collision Category</label>
                <input type="number" id="collision-category" style="width: 100%;">
            </div>
            <div class="input-group">
                <label>Collision Mask</label>
                <input type="number" id="collision-mask" style="width: 100%;">
            </div>
            <button id="delete-object-btn" class="delete-button" style="display: none;">Delete Object</button>
        </div>
    </div>

    <div id="controls-panel" class="ui-panel">
        <div class="control-group">
            <h3>Add Object</h3>
            <select id="object-type">
                <option value="circle">Circle</option>
                <option value="rectangle">Rectangle</option>
                <option value="triangle">Triangle</option>
            </select>
            <button id="add-object-btn" style="margin-top: 10px;">Add to Scene</button>
        </div>
        <div class="control-group">
            <h3>Composites</h3>
            <select id="composite-list"></select>
            <button id="add-composite-btn" style="margin-top: 10px;">Add New Composite</button>
        </div>
        <div class="control-group">
            <h3>Save/Load</h3>
            <button id="save-composite-btn">Save Selected</button>
            <button id="load-composite-btn" style="margin-top: 10px;">Load Composite</button>
        </div>
        <div class="control-group">
            <h3>Mode</h3>
            <div class="checkbox-group">
                <label for="build-mode-checkbox">Build Mode</label>
                <input type="checkbox" id="build-mode-checkbox">
            </div>
        </div>
        <div class="control-group" id="world-controls">
            <h3>World Properties</h3>
            <div class="slider-group">
                <label for="gravity-slider">Gravity Y: <span id="gravity-value">1.00</span></label>
                <input type="range" id="gravity-slider" min="0" max="2" step="0.01" value="1">
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="delete-modal" class="modal-overlay">
        <div class="modal-content">
            <p id="modal-text">You are about to delete this.</p>
            <div class="modal-buttons">
                <button id="confirm-delete">Confirm</button>
                <button id="deny-delete">Deny</button>
            </div>
        </div>
    </div>

    <div id="load-modal" class="modal-overlay">
        <div class="modal-content">
            <p>Paste composite JSON string below:</p>
            <textarea id="load-textarea"></textarea>
            <div class="modal-buttons">
                <button id="confirm-load">Load</button>
                <button id="deny-load">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Message Box -->
    <div id="copy-message" class="message-box"></div>

    <div class="instructions">
        <b>Left-click:</b> Select | <b>Right-click:</b> Select for constraint | <b>Drag:</b> Move
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="./libs/matter-tools.js"></script>
    <script>
        // --- SETUP ---
        const { Engine, Render, Runner, Bodies, Body, Composite, Constraint, Mouse, MouseConstraint, Events, Query, Vector, Vertices } = Matter;
        const engine = Engine.create();
        const world = engine.world;
        const render = Render.create({ element: document.body, engine: engine, options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: '#1a1a1a' } });
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);
        
        // --- SCENE OBJECTS ---
        const initialBodies = [
            Bodies.circle(window.innerWidth / 2 - 200, 200, 30, { render: { fillStyle: '#4285F4' } }),
            Bodies.rectangle(window.innerWidth / 2, 150, 50, 50, { render: { fillStyle: '#DB4437' } }),
            Bodies.polygon(window.innerWidth / 2 + 200, 200, 3, 30, { render: { fillStyle: '#0F9D58' } })
        ];
        Composite.add(world, initialBodies); 
        const wallOptions = { isStatic: true, render: { fillStyle: '#444' } };
        const wallThickness = 60;
        Composite.add(world, [
            Bodies.rectangle(window.innerWidth / 2, window.innerHeight - (wallThickness / 2), window.innerWidth, wallThickness, wallOptions),
            Bodies.rectangle(window.innerWidth / 2, (wallThickness / 2), window.innerWidth, wallThickness, wallOptions),
            Bodies.rectangle((wallThickness / 2), window.innerHeight / 2, wallThickness, window.innerHeight, wallOptions),
            Bodies.rectangle(window.innerWidth - (wallThickness / 2), window.innerHeight / 2, wallThickness, window.innerHeight, wallOptions)
        ]);

        // --- STATE & INTERACTIVITY ---
        let selectedBodies = [], selectedConstraint = null, selectedObject = null, selectedComposite = null;
        let isBuildMode = false;
        let draggingBody = null;
        let mouseDownPosition = null;
        let clickedBody = null;
        // State for cycling selection
        let lastClickPosition = { x: null, y: null };
        let candidateIndex = 0;
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, { mouse: mouse, constraint: { stiffness: 0.2, render: { visible: false } } });
        Composite.add(world, mouseConstraint);

        // All composites will be stored in this master composite. This prevents them from being part of the main world.
        const masterComposite = Composite.create({ label: 'Master Composite' });
        world.label = 'World';
        
        // --- SERIALIZER SETUP ---
        const serializer = MatterTools.Serializer.create();

        // --- UI ELEMENT REFERENCES ---
        const uiTitle = document.getElementById('ui-title'), 
              constraintEditor = document.getElementById('constraint-editor'), 
              objectEditor = document.getElementById('object-editor'),
              compositeEditor = document.getElementById('composite-editor'),
              assignToCompositeSection = document.getElementById('assign-to-composite-section');

        const deleteConstraintBtn = document.getElementById('delete-constraint-btn'), 
              deleteObjectBtn = document.getElementById('delete-object-btn'),
              deleteCompositeBtn = document.getElementById('delete-composite-btn');

        const deleteModal = document.getElementById('delete-modal'), 
              loadModal = document.getElementById('load-modal'),
              modalText = document.getElementById('modal-text'),
              loadTextarea = document.getElementById('load-textarea'),
              copyMessage = document.getElementById('copy-message');

        const compositeNameInput = document.getElementById('composite-name-input');
        const compositeList = document.getElementById('composite-list');
        const assignCompositeList = document.getElementById('assign-composite-list');

        // Save/Load Buttons
        const saveCompositeBtn = document.getElementById('save-composite-btn');
        const loadCompositeBtn = document.getElementById('load-composite-btn');

        // --- WORLD CONTROLS REFERENCES ---
        const gravitySlider = document.getElementById('gravity-slider');
        const gravityValueSpan = document.getElementById('gravity-value');
        gravityValueSpan.textContent = parseFloat(gravitySlider.value).toFixed(2);

        // --- UI LOGIC ---
        function showEditor(mode) {
            constraintEditor.style.display = 'none';
            objectEditor.style.display = 'none';
            compositeEditor.style.display = 'none';
            deleteConstraintBtn.style.display = 'none';
            deleteObjectBtn.style.display = 'none';
            deleteCompositeBtn.style.display = 'none';
            assignToCompositeSection.style.display = 'none';
            
            // Toggle save button based on selection
            saveCompositeBtn.disabled = !selectedComposite;
            saveCompositeBtn.style.opacity = selectedComposite ? 1 : 0.5;

            switch(mode) {
        case 'new':
            uiTitle.textContent = "New Constraint";
            constraintEditor.style.display = 'block';
            break;
        case 'constraint':
            uiTitle.textContent = "Edit Constraint";
            constraintEditor.style.display = 'block';
            deleteConstraintBtn.style.display = 'block';
            assignToCompositeSection.style.display = 'block';
            break;
        case 'object':
            uiTitle.textContent = "Edit Object";
            objectEditor.style.display = 'block';
            deleteObjectBtn.style.display = 'block';
            assignToCompositeSection.style.display = 'block';
            break;
        case 'composite':
            uiTitle.textContent = "Edit Composite";
            compositeEditor.style.display = 'block';
            deleteCompositeBtn.style.display = 'block';
            break;
        case 'composite-child':
            uiTitle.textContent = "Edit Composite";
            compositeEditor.style.display = 'block';
            document.getElementById('remove-from-composite-btn').style.display = 'block';
            document.getElementById('composite-editor-message').style.display = 'block';
            deleteCompositeBtn.style.display = 'none';
            break;
    }
}

        // --- ADD OBJECT LOGIC ---
        document.getElementById('add-object-btn').addEventListener('click', () => {
            const objectType = document.getElementById('object-type').value;
            const x = window.innerWidth * (0.4 + Math.random() * 0.2);
            let newBody;
            const randomColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            const options = { render: { fillStyle: randomColor } };
            if (objectType === 'circle') {
                newBody = Bodies.circle(x, 100, 30, options);
            } else if (objectType === 'rectangle') {
                newBody = Bodies.rectangle(x, 100, 50, 80, options);
            } else if (objectType === 'triangle') {
                newBody = Bodies.polygon(x, 100, 3, 40, options);
            }
            Composite.add(world, newBody);
        });
        // --- CONSTRAINTS LOGIC --- ADDED BY THEGINKO
        function updateConstraintList() {
    const constraintsList = document.getElementById('existing-constraint-list');
    constraintsList.innerHTML = '<option value="new">Create New...</option>';
    const allConstraints = Composite.allConstraints(world).concat(Composite.allConstraints(masterComposite));

    allConstraints.forEach(c => {
        const option = document.createElement('option');
        option.value = c.id;
        option.textContent = `Constraint ${c.id}`;
        constraintsList.appendChild(option);
    });

    // Set the dropdown to the currently selected constraint, if one exists
    if (selectedConstraint) {
        constraintsList.value = selectedConstraint.id;
    } else {
        constraintsList.value = 'new';
    }
}
        // --- COMPOSITES LOGIC ---
        function updateCompositeLists() {
            // Clear existing lists
            compositeList.innerHTML = '<option value="none">World</option>';
            assignCompositeList.innerHTML = '';
            
            const composites = masterComposite.composites;
            composites.forEach(comp => {
                const option = document.createElement('option');
                option.value = comp.id;
                option.textContent = comp.label;
                compositeList.appendChild(option);

                const assignOption = option.cloneNode(true);
                assignCompositeList.appendChild(assignOption);
            });

            // Update selection in list
            if (selectedComposite) {
                compositeList.value = selectedComposite.id;
            } else {
                compositeList.value = 'none';
            }
        }
        
        function addComposite() {
            const newComposite = Composite.create({ label: `Composite ${masterComposite.composites.length + 1}` });
            Composite.add(masterComposite, newComposite);
            updateCompositeLists();
        }

        function deleteComposite() {
            if (selectedComposite) {
                Composite.remove(masterComposite, selectedComposite);
                deselectAll();
            }
        }
        function removeFromComposite() {
    if (selectedObject) {
        const parentComposite = selectedObject.parent;
        if (parentComposite && parentComposite !== world) {
            Composite.remove(parentComposite, selectedObject);
            Composite.add(world, selectedObject);
            deselectAll();
            showMessage("Object removed from composite.", 'success');
        } else {
            showMessage("Object is not in a composite.", 'error');
        }
    } else if (selectedConstraint) {
         const parentComposite = selectedConstraint.parent;
         if (parentComposite && parentComposite !== world) {
             Composite.remove(parentComposite, selectedConstraint);
             Composite.add(world, selectedConstraint);
             deselectAll();
             showMessage("Constraint removed from composite.", 'success');
         } else {
             showMessage("Constraint is not in a composite.", 'error');
         }
    } else {
         showMessage("No object or constraint selected to remove.", 'error');
    }
}
document.getElementById('remove-from-composite-btn').addEventListener('click', removeFromComposite);
        document.getElementById('add-composite-btn').addEventListener('click', addComposite);

        compositeList.addEventListener('change', (e) => {
            const compositeId = e.target.value;
            if (compositeId === 'none') {
                selectedComposite = null;
            } else {
                selectedComposite = Composite.get(masterComposite, compositeId, 'composite');
            }
            showEditor('composite');
            if (selectedComposite) {
                compositeNameInput.value = selectedComposite.label;
            }
            updateSelectionVisuals();
        });

        compositeNameInput.addEventListener('input', (e) => {
            if (selectedComposite) {
                selectedComposite.label = e.target.value;
                updateCompositeLists();
            }
        });
        
        document.getElementById('add-to-composite-btn').addEventListener('click', () => {
    if (selectedObject) {
        const targetCompositeId = assignCompositeList.value;
        if (targetCompositeId && targetCompositeId !== 'none') { // Ensure a composite is selected
            const targetComposite = Composite.get(masterComposite, targetCompositeId, 'composite');
            
            let parentComposite = world; // Assume world is the parent initially

            // Check if the object is directly in the world's bodies
            if (!world.bodies.includes(selectedObject)) {
                // If not in world.bodies, search within masterComposite and its sub-composites
                // Matter.js composites have a 'parent' property referencing their containing composite
                // We can traverse up the parent chain from the selected object's parent
                let currentParent = selectedObject.parent;
                while (currentParent && currentParent !== world) {
                    if (masterComposite.composites.includes(currentParent)) {
                        parentComposite = currentParent;
                        break; // Found the parent composite within masterComposite
                    }
                    currentParent = currentParent.parent;
                }
            }

            console.log('Assign button clicked. Selected Object:', selectedObject);
            console.log('Assign Composite List value:', targetCompositeId);
            console.log('Parent Composite:', parentComposite);
            console.log('Target Composite:', targetComposite);

            if (parentComposite && targetComposite) { // Ensure both parent and target composites are found
                 // Check if the selected object is already in the target composite
                if (!Composite.allBodies(targetComposite).includes(selectedObject)) {
                     Composite.move(parentComposite, [selectedObject], targetComposite);
                } else {
                    console.log('Object is already in the target composite.');
                     showMessage('Object is already in the selected composite.', 'info');
                }
               
            } else {
                 showMessage('Please select a composite to assign to.', 'info');
            }
            deselectAll();
        } else {
             showMessage('Please select a composite to assign to.', 'info');
        }
    }
});


        // --- SAVE/LOAD LOGIC ---
        function saveComposite() {
            if (!selectedComposite) {
                showMessage("No composite selected to save.", 'error');
                return;
            }
            try {
                const jsonString = MatterTools.Serializer.serialise(serializer, selectedComposite, 2);
                navigator.clipboard.writeText(jsonString).then(() => {
                    showMessage("Composite JSON copied to clipboard!");
                }, (err) => {
                    showMessage("Failed to copy JSON to clipboard.", 'error');
                    console.error("Could not copy text: ", err);
                });
            } catch (err) {
                showMessage("Failed to serialize composite.", 'error');
                console.error("Serialization error: ", err);
            }
        }

        function loadComposite() {
    const jsonString = loadTextarea.value;
    try {
        const newComposite = serializer.parse(jsonString);

        // Fix the collision issue by setting the group to 0
        const bodiesInComposite = Composite.allBodies(newComposite);
        for (const body of bodiesInComposite) {
            body.collisionFilter.group = 0;
        }

        Composite.add(masterComposite, newComposite);
        updateCompositeLists();
        loadModal.style.display = 'none';
        showMessage("Composite loaded successfully!");
    } catch (err) {
        showMessage("Invalid JSON string. Please check the format.", 'error');
        console.error("Deserialization error: ", err);
    }
}

        function showMessage(text, type = 'success') {
            copyMessage.textContent = text;
            copyMessage.style.backgroundColor = type === 'error' ? '#DB4437' : '#0F9D58';
            copyMessage.style.opacity = 1;
            setTimeout(() => { copyMessage.style.opacity = 0; }, 2000);
        }

        saveCompositeBtn.addEventListener('click', saveComposite);
        loadCompositeBtn.addEventListener('click', () => { loadModal.style.display = 'flex'; });
        document.getElementById('confirm-load').addEventListener('click', loadComposite);
        document.getElementById('deny-load').addEventListener('click', () => { loadModal.style.display = 'none'; });

        // --- BUILD MODE LOGIC ---
        document.getElementById('build-mode-checkbox').addEventListener('change', (e) => {
             isBuildMode = e.target.checked;
             if (isBuildMode) {
                engine.gravity.y = 0;
                Composite.remove(world, mouseConstraint); 
            } else {
                 engine.gravity.y = 1;
                 Composite.add(world, mouseConstraint); 
            }
        });

        // --- DELETE LOGIC ---
        function showConfirmationModal(type) {
            modalText.textContent = `You are about to delete this ${type}.`;
            deleteModal.style.display = 'flex';
        }
        deleteConstraintBtn.addEventListener('click', () => showConfirmationModal('constraint'));
        deleteObjectBtn.addEventListener('click', () => showConfirmationModal('object'));
        deleteCompositeBtn.addEventListener('click', () => showConfirmationModal('composite'));

        document.getElementById('deny-delete').addEventListener('click', () => deleteModal.style.display = 'none');
        document.getElementById('confirm-delete').addEventListener('click', () => {
            if (selectedComposite) {
                deleteComposite();
            } else if (selectedConstraint) {
                Composite.remove(world, selectedConstraint);
                deselectAll();
            } else if (selectedObject) {
                Composite.remove(world, selectedObject);
                deselectAll();
            }
            deleteModal.style.display = 'none';
        });
        // RANGE SCALING FOR SLIDERS LOGIC AND UPDATE
        function scaleSliderRange(slider, scaleFactor) {
    const currentMin = parseFloat(slider.min);
    const currentMax = parseFloat(slider.max);
    const currentStep = parseFloat(slider.step);

    let newMin = currentMin * scaleFactor;
    let newMax = currentMax * scaleFactor;
    let newStep = currentStep * scaleFactor;

    // Prevent range from collapsing to zero or becoming too small
    if (newMax < newMin + newStep) {
        newMax = newMin + newStep;
    }

    slider.min = newMin;
    slider.max = newMax;
    slider.step = newStep;

    // Update the display for the new range
    const rangeDisplay = slider.closest('.slider-with-controls').querySelector('.range-display');
    rangeDisplay.textContent = `Range: ${newMin} - ${newMax}`;
}
        // --- PROPERTY HANDLERS ---
        function setupPropertyHandlers() {
            const inputs = {
                isStatic: document.getElementById('is-static'),
                angle: document.getElementById('angle'),
                restitution: document.getElementById('restitution'),
                friction: document.getElementById('friction'),
                frictionStatic: document.getElementById('friction-static'),
                frictionAir: document.getElementById('friction-air'),
                density: document.getElementById('density'),
                posX: document.getElementById('position-x'),
                posY: document.getElementById('position-y'),
                comX: document.getElementById('com-offset-x'),
                comY: document.getElementById('com-offset-y'),
                radius: document.getElementById('radius'),
                width: document.getElementById('width'),
                height: document.getElementById('height'),
                polygonSize: document.getElementById('polygon-size'),
                group: document.getElementById('collision-group'),
                category: document.getElementById('collision-category'),
                mask: document.getElementById('collision-mask'),
                stiffness: document.getElementById('stiffness'),
                damping: document.getElementById('damping'),
                length: document.getElementById('length'),
                constraintPointAX: document.getElementById('constraint-point-ax'),
                constraintPointAY: document.getElementById('constraint-point-ay'),
                constraintPointBX: document.getElementById('constraint-point-bx'),
                constraintPointBY: document.getElementById('constraint-point-by')
            };

            inputs.isStatic.addEventListener('change', () => {
                if (selectedObject) Body.setStatic(selectedObject, inputs.isStatic.checked);
            });
            inputs.angle.addEventListener('input', () => {
                if (selectedObject) Body.setAngle(selectedObject, parseFloat(inputs.angle.value) * (Math.PI / 180));
                updateEditorLabels();
            });
            inputs.restitution.addEventListener('input', () => {
                if (selectedObject) selectedObject.restitution = parseFloat(inputs.restitution.value);
                updateEditorLabels();
            });
            inputs.friction.addEventListener('input', () => {
                if (selectedObject) selectedObject.friction = parseFloat(inputs.friction.value);
                updateEditorLabels();
            });
            inputs.frictionStatic.addEventListener('input', () => {
                if (selectedObject) selectedObject.frictionStatic = parseFloat(inputs.frictionStatic.value);
                updateEditorLabels();
            });
            inputs.frictionAir.addEventListener('input', () => {
                if (selectedObject) selectedObject.frictionAir = parseFloat(inputs.frictionAir.value);
                updateEditorLabels();
            });
            inputs.density.addEventListener('input', () => {
                if (selectedObject) Body.setDensity(selectedObject, parseFloat(inputs.density.value));
                updateEditorLabels();
            });
            inputs.posX.addEventListener('input', () => {
                if (selectedObject) Body.setPosition(selectedObject, { x: parseFloat(inputs.posX.value), y: selectedObject.position.y });
                updateEditorLabels();
            });
            inputs.posY.addEventListener('input', () => {
                if (selectedObject) Body.setPosition(selectedObject, { x: selectedObject.position.x, y: parseFloat(inputs.posY.value) });
                updateEditorLabels();
            });
             inputs.comX.addEventListener('input', () => {
                if (selectedObject) {
                    const newOffsetX = parseFloat(inputs.comX.value) || 0;
                    const currentOffsetY = parseFloat(inputs.comY.value) || 0;
                    Body.setCentre(selectedObject, { x: newOffsetX, y: currentOffsetY }, true);
                }
            });
            inputs.comY.addEventListener('input', () => {
                if (selectedObject) {
                    const newOffsetY = parseFloat(inputs.comY.value) || 0;
                    const currentOffsetX = parseFloat(inputs.comX.value) || 0;
                    Body.setCentre(selectedObject, { x: currentOffsetX, y: newOffsetY }, true);
                }
            });
            inputs.radius.addEventListener('input', () => {
                if (selectedObject && selectedObject.circleRadius) {
                    const newRadius = parseFloat(inputs.radius.value);
                    const oldRadius = selectedObject.circleRadius;
                    if (oldRadius > 0) Body.scale(selectedObject, newRadius / oldRadius, newRadius / oldRadius);
                }
                updateEditorLabels();
            });
            inputs.width.addEventListener('input', () => {
                if (selectedObject && !selectedObject.circleRadius) {
                    const newWidth = parseFloat(inputs.width.value);
                    const oldWidth = selectedObject.bounds.max.x - selectedObject.bounds.min.x;
                    if (oldWidth > 0) Body.scale(selectedObject, newWidth / oldWidth, 1);
                }
                updateEditorLabels();
            });
            inputs.height.addEventListener('input', () => {
                if (selectedObject && !selectedObject.circleRadius) {
                    const newHeight = parseFloat(inputs.height.value);
                    const oldHeight = selectedObject.bounds.max.y - selectedObject.bounds.min.y;
                    if (oldHeight > 0) Body.scale(selectedObject, 1, newHeight / oldHeight);
                }
                updateEditorLabels();
            });
            inputs.polygonSize.addEventListener('input', () => {
                if (selectedObject && !selectedObject.circleRadius && selectedObject.vertices.length !== 4) {
                    const newSize = parseFloat(inputs.polygonSize.value);
                    const currentSize = Math.sqrt(selectedObject.area / (selectedObject.vertices.length === 3 ? 0.433 : 1));
                    const scaleFactor = newSize / currentSize;
                    if (currentSize > 0 && isFinite(scaleFactor)) {
                        Body.scale(selectedObject, scaleFactor, scaleFactor);
                    }
                }
                updateEditorLabels();
            });
            inputs.group.addEventListener('input', () => {
                if (selectedObject && !isNaN(parseInt(inputs.group.value))) selectedObject.collisionFilter.group = parseInt(inputs.group.value);
            });
            inputs.category.addEventListener('input', () => {
                if (selectedObject && !isNaN(parseInt(inputs.category.value))) selectedObject.collisionFilter.category = parseInt(inputs.category.value);
            });
            inputs.mask.addEventListener('input', () => {
                if (selectedObject && !isNaN(parseInt(inputs.mask.value))) selectedObject.collisionFilter.mask = parseInt(inputs.mask.value);
            });

            // Constraint Listeners
            inputs.stiffness.addEventListener('input', () => {
                if(selectedConstraint) selectedConstraint.stiffness = parseFloat(inputs.stiffness.value);
                updateEditorLabels();
            });
            inputs.damping.addEventListener('input', () => {
                if(selectedConstraint) selectedConstraint.damping = parseFloat(inputs.damping.value);
                updateEditorLabels();
            });
            inputs.length.addEventListener('input', () => {
                if(selectedConstraint) selectedConstraint.length = parseFloat(inputs.length.value);
                updateEditorLabels();
            });
            inputs.constraintPointAX.addEventListener('input', () => {
                if(selectedConstraint) selectedConstraint.pointA.x = parseFloat(inputs.constraintPointAX.value);
            });
            inputs.constraintPointAY.addEventListener('input', () => {
                if(selectedConstraint) selectedConstraint.pointA.y = parseFloat(inputs.constraintPointAY.value);
            });
            inputs.constraintPointBX.addEventListener('input', () => {
                if(selectedConstraint) selectedConstraint.pointB.x = parseFloat(inputs.constraintPointBX.value);
            });
            inputs.constraintPointBY.addEventListener('input', () => {
                if(selectedConstraint) selectedConstraint.pointB.y = parseFloat(inputs.constraintPointBY.value);
            });

            // Add this section to the bottom of the function
document.querySelectorAll('.range-and-controls button').forEach(button => {
    button.addEventListener('click', () => {
        const sliderId = button.dataset.target;
        const slider = document.getElementById(sliderId);
        const scale = parseFloat(button.dataset.scale);
        scaleSliderRange(slider, scale);
    });
});
        }
        setupPropertyHandlers();

        function updateEditorLabels() {
            if (selectedObject) {
                document.getElementById('angle-value').textContent = Math.round(selectedObject.angle * (180 / Math.PI)) % 360;
                document.getElementById('restitution-value').textContent = selectedObject.restitution.toFixed(2);
                document.getElementById('friction-value').textContent = selectedObject.friction.toFixed(2);
                document.getElementById('friction-static-value').textContent = selectedObject.frictionStatic.toFixed(2);
                document.getElementById('friction-air-value').textContent = selectedObject.frictionAir.toFixed(3);
                document.getElementById('density-value').textContent = selectedObject.density.toFixed(3);
                if (selectedObject.circleRadius > 0) {
                    document.getElementById('radius-value').textContent = Math.round(selectedObject.circleRadius);
                } else if (selectedObject.vertices.length === 4) {
                    document.getElementById('width-value').textContent = Math.round(selectedObject.bounds.max.x - selectedObject.bounds.min.x);
                    document.getElementById('height-value').textContent = Math.round(selectedObject.bounds.max.y - selectedObject.bounds.min.y);
                } else {
                    const size = Math.sqrt(selectedObject.area / (selectedObject.vertices.length === 3 ? 0.433 : 1));
                    document.getElementById('polygon-size-value').textContent = Math.round(size);
                }
            }
            if (selectedConstraint) {
                document.getElementById('stiffness-value').textContent = selectedConstraint.stiffness.toFixed(2);
                document.getElementById('damping-value').textContent = selectedConstraint.damping.toFixed(3);
                document.getElementById('length-value').textContent = Math.round(selectedConstraint.length);
            }
        }

        function populateEditor(item) {
            if (item.type === 'body') {
                const body = item;
                const isCircle = body.circleRadius > 0;
                const isRectangle = !isCircle && body.vertices.length === 4;
                
                document.getElementById('size-editor-circle').style.display = 'none';
                document.getElementById('size-editor-rect').style.display = 'none';
                document.getElementById('size-editor-polygon').style.display = 'none';

                if (isCircle) {
                    document.getElementById('size-editor-circle').style.display = 'block';
                    document.getElementById('radius').value = body.circleRadius;
                } else if (isRectangle) {
                    document.getElementById('size-editor-rect').style.display = 'block';
                    document.getElementById('width').value = body.bounds.max.x - body.bounds.min.x;
                    document.getElementById('height').value = body.bounds.max.y - body.bounds.min.y;
                    document.querySelector('#size-editor-rect .range-display').textContent = `Range: 10 - 200`;
                    document.querySelector('#size-editor-rect .range-display').textContent = `Range: 10 - 200`;
                } else { 
                    document.getElementById('size-editor-polygon').style.display = 'block';
                    const size = Math.sqrt(body.area / (body.vertices.length === 3 ? 0.433 : 1));
                    document.getElementById('polygon-size').value = size;
                }

                document.getElementById('is-static').checked = body.isStatic;
                document.getElementById('angle').value = Math.round(body.angle * (180 / Math.PI)) % 360;
                document.getElementById('restitution').value = body.restitution;
                document.getElementById('friction').value = body.friction;
                document.getElementById('friction-static').value = body.frictionStatic;
                document.getElementById('friction-air').value = body.frictionAir;
                document.getElementById('density').value = body.density;
                document.getElementById('position-x').value = Math.round(body.position.x);
                document.getElementById('position-y').value = Math.round(body.position.y);

                const geometricCenter = Vertices.centre(body.vertices);
                const offsetX = body.position.x - geometricCenter.x;
                const offsetY = body.position.y - geometricCenter.y;
                document.getElementById('com-offset-x').value = Math.round(offsetX);
                document.getElementById('com-offset-y').value = Math.round(offsetY);
                
                document.getElementById('collision-group').value = body.collisionFilter.group;
                document.getElementById('collision-category').value = body.collisionFilter.category;
                document.getElementById('collision-mask').value = body.collisionFilter.mask;
                
                assignToCompositeSection.style.display = 'block';
            } else if (item.type === 'constraint') {
                const constraint = item;
                document.getElementById('stiffness').value = constraint.stiffness;
                document.getElementById('damping').value = constraint.damping;
                document.getElementById('length').value = constraint.length;
                document.getElementById('constraint-point-ax').value = constraint.pointA.x;
                document.getElementById('constraint-point-ay').value = constraint.pointA.y;
                document.getElementById('constraint-point-bx').value = constraint.pointB.x;
                document.getElementById('constraint-point-by').value = constraint.pointB.y;

                assignToCompositeSection.style.display = 'block';
            }
            updateEditorLabels();
        }

        gravitySlider.addEventListener('input', function() {
            const gravityValue = parseFloat(this.value);
            engine.gravity.y = gravityValue;
            gravityValueSpan.textContent = gravityValue.toFixed(2);
        });

        const distToSegment = (p, v, w) => {
            const l2 = Vector.magnitudeSquared(Vector.sub(w, v)); if (l2 === 0) return Vector.magnitude(Vector.sub(p, v));
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
            return Vector.magnitude(Vector.sub(p, projection));
        };

        const updateSelectionVisuals = () => {
            // Reset all borders
            world.bodies.forEach(body => { body.render.lineWidth = 0; });
            Composite.allConstraints(world).forEach(c => { c.render.lineWidth = 2; c.render.strokeStyle = '#999'; });
            selectedBodies.forEach(body => { body.render.strokeStyle = '#F4B400'; body.render.lineWidth = 3; });
            
            // Highlight selected object/constraint
            if (selectedObject) { selectedObject.render.strokeStyle = '#F4B400'; selectedObject.render.lineWidth = 4; }
            if (selectedConstraint) { selectedConstraint.render.strokeStyle = '#F4B400'; selectedConstraint.render.lineWidth = 4; }

            // Highlight selected composite
            if (selectedComposite) {
                const allBodies = Composite.allBodies(selectedComposite);
                const allConstraints = Composite.allConstraints(selectedComposite);
                allBodies.forEach(body => { body.render.strokeStyle = '#0F9D58'; body.render.lineWidth = 4; });
                allConstraints.forEach(c => { c.render.strokeStyle = '#0F9D58'; c.render.lineWidth = 4; });
            }
        };
        
        const deselectAll = () => {
    selectedBodies = []; 
    selectedConstraint = null; 
    selectedObject = null;
    selectedComposite = null;
    showEditor('new'); 
    updateSelectionVisuals();
    updateCompositeLists();
    updateConstraintList();
};

        let isDragging = false;
        const dragThreshold = 5;

        render.canvas.addEventListener('mousemove', function(event) {
            if (isBuildMode && draggingBody) {
                const currentMousePosition = { x: event.offsetX, y: event.offsetY };
                Body.setPosition(draggingBody, currentMousePosition);
            }
        });

         render.canvas.addEventListener('mousedown', function(event) {
            if (isBuildMode) {
                mouseDownPosition = { x: event.offsetX, y: event.offsetY };
                const mousePosition = { x: event.offsetX, y: event.offsetY };
                const clickedBodies = Query.point(world.bodies, mousePosition);
                
                if (clickedBodies.length > 0) {
                    clickedBody = clickedBodies[0];
                    isDragging = false;
                } else {
                    clickedBody = null;
                    deselectAll();
                }
                event.preventDefault();
            }
        });


        render.canvas.addEventListener('mouseup', function(event) {
            if (isBuildMode) {
                if (isDragging) {
                    isDragging = false;
                    draggingBody = null;
                } else if (clickedBody) {
                    deselectAll();

                    const compositeParent = Composite.get(masterComposite, clickedBody.id, 'body');
                    if (compositeParent) {
                        selectedComposite = compositeParent;
                        showEditor('composite');
                        compositeNameInput.value = selectedComposite.label;
                    } else {
                        selectedObject = clickedBody;
                        showEditor('object');
                        populateEditor(selectedObject);
                    }
                    updateSelectionVisuals();
                }
                clickedBody = null;
                mouseDownPosition = null;
            }
        });

        // --- UNIFIED SELECTION LOGIC ---
        render.canvas.addEventListener('mousedown', function(event) {
    if (isBuildMode) return;

    const mousePosition = { x: event.offsetX, y: event.offsetY };
    const clickTolerance = 5;

    // Check if this click is very close to the last one
    const isSameClick = lastClickPosition.x !== null && 
                        Vector.magnitude(Vector.sub(mousePosition, lastClickPosition)) < clickTolerance;

    let candidates = [];

    // Gather all bodies under the mouse
    const allBodies = Composite.allBodies(world).concat(Composite.allBodies(masterComposite));
    const bodiesUnderMouse = Query.point(allBodies, mousePosition);
    candidates.push(...bodiesUnderMouse);

    // Gather all constraints under the mouse
    const allConstraints = Composite.allConstraints(world).concat(Composite.allConstraints(masterComposite));
    for (const constraint of allConstraints) {
        if (!constraint.bodyA || !constraint.bodyB) continue;
        if (distToSegment(mousePosition, constraint.bodyA.position, constraint.bodyB.position) < 10) {
            candidates.push(constraint);
        }
    }

    const filteredCandidates = candidates;

    if (event.button === 0) { // Left-click for selection
        if (filteredCandidates.length > 0) {
            if (isSameClick) {
                candidateIndex = (candidateIndex + 1) % filteredCandidates.length;
            } else {
                candidateIndex = 0;
            }

            const selectedItem = filteredCandidates[candidateIndex];
            deselectAll();

            if (selectedItem.type === 'body') {
    // Check if the body belongs to a composite
    let parentComposite = null;
    for (const comp of masterComposite.composites) {
        if (Composite.allBodies(comp).some(body => body.id === selectedItem.id)) {
            parentComposite = comp;
            break;
        }
    }

    if (parentComposite) {
        selectedComposite = parentComposite;
        selectedObject = selectedItem; // Keep reference to the child object
        showEditor('composite-child'); // Show the new UI for a child object
        compositeNameInput.value = selectedComposite.label;
    } else {
        selectedObject = selectedItem;
        showEditor('object');
        populateEditor(selectedObject);
    }
} else if (selectedItem.type === 'constraint') {
    // Check if the constraint belongs to a composite
     let parentComposite = null;
    for (const comp of masterComposite.composites) {
        if (Composite.allConstraints(comp).some(constraint => constraint.id === selectedItem.id)) {
            parentComposite = comp;
            break;
        }
    }

    if (parentComposite) {
        selectedComposite = parentComposite;
        selectedConstraint = selectedItem; // Keep reference to the child constraint
        showEditor('composite-child'); // Show the new UI for a child constraint
        compositeNameInput.value = selectedComposite.label;
    } else {
        selectedConstraint = selectedItem;
        showEditor('constraint');
        populateEditor(selectedConstraint);
    }
}

                if (parentComposite) {
                    selectedComposite = parentComposite;
                    showEditor('composite');
                    compositeNameInput.value = selectedComposite.label;
                } else {
                    selectedObject = selectedItem;
                    showEditor('object');
                    populateEditor(selectedObject);
                }
            } else if (selectedItem.type === 'constraint') {
                 let parentComposite = null;
                for (const comp of masterComposite.composites) {
                    if (Composite.allConstraints(comp).some(constraint => constraint.id === selectedItem.id)) {
                        parentComposite = comp;
                        break;
                    }
                }

                if (parentComposite) {
                    selectedComposite = parentComposite;
                    showEditor('composite');
                    compositeNameInput.value = selectedComposite.label;
                } else {
                    selectedConstraint = selectedItem;
                    showEditor('constraint');
                    populateEditor(selectedConstraint);
                }
            }
        } else {
            deselectAll();
        }

        lastClickPosition = { x: mousePosition.x, y: mousePosition.y };
        updateSelectionVisuals();
    } 
        else if (event.button === 2) { // Right-click for constraints
        const clickedBodies = Query.point(world.bodies, mousePosition);
        if (clickedBodies.length > 0) {
            const body = clickedBodies[0];
            const index = selectedBodies.indexOf(body);
            if (index === -1) {
                if (selectedBodies.length < 2) {
                    selectedBodies.push(body);
                }
            } else {
                selectedBodies.splice(index, 1);
            }

            if (selectedBodies.length === 2) {
                const newConstraint = Constraint.create({
                    bodyA: selectedBodies[0], bodyB: selectedBodies[1],
                    stiffness: 0.01, damping: 0.05, length: 100,
                    render: { strokeStyle: '#999', lineWidth: 2 }
                });
                Composite.add(world, newConstraint);
                selectedBodies = [];
            }
            updateSelectionVisuals();
        }
    }
});

        // --- CUSTOM RENDERING ---
        Events.on(render, 'afterRender', function() {
            if (!selectedObject) return;
            const context = render.context;
            const geomCenterX = (selectedObject.bounds.min.x + selectedObject.bounds.max.x) / 2;
            const geomCenterY = (selectedObject.bounds.min.y + selectedObject.bounds.max.y) / 2;

            context.beginPath();
            context.arc(geomCenterX, geomCenterY, 5, 0, 2 * Math.PI);
            context.fillStyle = 'rgba(0, 255, 255, 0.7)';
            context.fill();

            context.beginPath();
            context.arc(selectedObject.position.x, selectedObject.position.y, 5, 0, 2 * Math.PI);
            context.fillStyle = 'rgba(255, 255, 0, 0.7)';
            context.fill();
        });
        
        render.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth; render.canvas.height = window.innerHeight;
            render.options.width = window.innerWidth; render.options.height = window.innerHeight;
        });
        //EVENT LISTENER FOR CONSTRAINTS
        document.getElementById('existing-constraint-list').addEventListener('change', (e) => {
    const constraintId = e.target.value;

    if (constraintId === 'new') {
        deselectAll();
    } else {
        const allConstraints = Composite.allConstraints(world).concat(Composite.allConstraints(masterComposite));
        const selectedItem = allConstraints.find(c => c.id == constraintId);
        if (selectedItem) {
            deselectAll();
            selectedConstraint = selectedItem;
            showEditor('constraint');
            populateEditor(selectedConstraint);
            updateSelectionVisuals();
        }
    }
});
        // --- INITIALIZATION ---
        window.onload = function() {
            Composite.add(world, masterComposite); // Add master composite to the world
            updateCompositeLists();
            updateConstraintList();
        };

    </script>
</body>
</html>
